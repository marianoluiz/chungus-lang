// Chungus Language Lark Grammar (NEW CFG)

start: program

program: newline_opt global_statement global_statement_tail

newline_opt: NEWLINE newline_opt
           | 

global_statement: general_statement
                | function_statement

global_statement_tail: global_statement global_statement_tail
                     | NEWLINE global_statement_tail
                     | 

general_statement: id_statement NEWLINE
                 | output_statement NEWLINE
                 | system_command_statement NEWLINE
                 | control_structure_statement
                 | error_handling_statement NEWLINE
                 | todo_statement NEWLINE
                 | array_manip_statement NEWLINE

id_statement: ID id_tail

id_tail: unary_suffix
       | "=" id_value

unary_suffix: UN_PLUS
            | UN_MINUS

id_value: assignment_value
        | READ
        | "[" element_list "]"

assignment_value: type_casting
                | expr

type_casting: INT "(" int_float_str_lit ")"
            | FLOAT "(" int_float_str_lit ")"

// ─────────── EXPRESSIONS ───────────

expr: logical_or_expr

logical_or_expr: logical_and_expr logical_or_expr_tail
logical_or_expr_tail: OR logical_and_expr logical_or_expr_tail
                    | 

logical_and_expr: logical_not_expr logical_and_expr_tail
logical_and_expr_tail: AND logical_not_expr logical_and_expr_tail
                     | 

logical_not_expr: NOT bool_primary
                | bool_primary

bool_primary: "(" expr ")"
            | eq_expr

eq_expr: comp_operand eq_expr_tail

comp_operand: rel_expr
            | str_primary
            | TRUE
            | FALSE


eq_expr_tail: EQ_EQ comp_operand eq_expr_tail
            | NOT_EQ comp_operand eq_expr_tail
            | 

str_primary: STR_LITERAL

rel_expr: arith_expr rel_expr_tail
rel_expr_tail: rel_op arith_expr rel_expr_tail
             | 

rel_op: GT
      | LT
      | GE
      | LE

arith_expr: term arith_expr_tail
arith_expr_tail: "+" term arith_expr_tail
               | "-" term arith_expr_tail
               | 

term: factor term_tail
term_tail: "*" factor term_tail
         | "/" factor term_tail
         | FLOORDIV factor term_tail
         | "%" factor term_tail
         | 

factor: power factor_tail
factor_tail: POW factor
           | 

power: neg_opt int_float_lit
     | ID array_fncall_opt
     | "(" expr ")"

neg_opt: "-"
       | 

// ─────────── LITERALS / ARRAY RULES ───────────

literal: int_float_str_bool_lit
       | "[" element_list "]"

int_float_str_lit: STR_LITERAL
                 | int_float_lit

int_float_str_bool_lit: int_float_str_lit
                      | TRUE
                      | FALSE

int_float_lit: INT_LITERAL
             | FLOAT_LITERAL

array_fncall_opt: "[" call_element_list "]" array_call_tail
                | "(" arg_list_opt ")"
                | 

call_element_list: INT_LITERAL

array_call_tail: "[" call_element_list "]" array_call_tail
               | 

element_list: array_element array_tail
            | 

array_tail: "," array_element array_tail
          | 

array_element: literal
             | ID

arg_list_opt: arg_list
            | 

arg_list: pos_arg def_arg_opt
        | def_arg

pos_arg: un_defined_arg pos_arg_tail
pos_arg_tail: "," un_defined_arg pos_arg_tail
            | 

def_arg: defined_arg def_arg_tail
def_arg_tail: "," defined_arg def_arg_tail
            | 

def_arg_opt: "," def_arg
           | 

defined_arg: ID "=" expr
un_defined_arg: expr

// ─────────── OUTPUT / SYSTEM COMMANDS ───────────

output_statement: SHOW output_value
output_value: ID
            | STR_LITERAL

system_command_statement: CLR
                        | EXIT

// ─────────── CONTROL STRUCTURES ───────────

control_structure_statement: conditional_statement
                           | looping_statement

conditional_statement: if_block elif_block else_block CLOSE NEWLINE

if_block: IF condition NEWLINE local_statement 
elif_block: ELIF condition NEWLINE local_statement elif_block
          | 
else_block: ELSE NEWLINE local_statement
          | 

condition: expr

local_statement: newline_opt general_statement general_statement_tail

general_statement_tail: NEWLINE general_statement_tail
                      | general_statement general_statement_tail
                      | 

looping_statement: for_statement
                 | while_statement

for_statement: FOR ID IN range_expression NEWLINE local_statement CLOSE NEWLINE

range_expression: RANGE "(" expression_list ")"
expression_list: expr range_tail_1

range_tail_1: "," expr range_tail_2
            | 
range_tail_2: "," expr
            | 

while_statement: WHILE condition NEWLINE local_statement CLOSE NEWLINE

// ─────────── FUNCTIONS ───────────

function_statement: FN ID "(" param ")" NEWLINE local_statement return_opt CLOSE NEWLINE

param: arg_list_opt

return_opt: return_statement newline_opt
          | 

return_statement: RET expr NEWLINE

// ─────────── ERROR HANDLING ───────────

error_handling_statement: try_block fail_block error_handling_tail CLOSE NEWLINE

error_handling_tail: always_block
                   | 

try_block: TRY NEWLINE local_statement 
fail_block: FAIL NEWLINE local_statement 
always_block: ALWAYS NEWLINE local_statement 

// ─────────── TODO ───────────

todo_statement: TODO

// ─────────── ARRAY MANIPULATION ───────────

array_manip_statement: ARRAY_ADD "(" ID array_fncall_opt "," expr ")"
                     | ARRAY_REMOVE "(" ID array_fncall_opt "," expr ")"

// ─────────── TERMINALS ───────────

AND: "and"
OR: "or"
NOT: "!"
TRUE: "true"
FALSE: "false"
READ: "read"
SHOW: "show"
CLR: "clr"
EXIT: "exit"
IF: "if"
ELIF: "elif"
ELSE: "else"
WHILE: "while"
FOR: "for"
IN: "in"
RANGE: "range"
FN: "fn"
RET: "ret"
TRY: "try"
FAIL: "fail"
ALWAYS: "always"
TODO: "todo"
ARRAY_ADD: "array_add"
ARRAY_REMOVE: "array_remove"
INT: "int"
FLOAT: "float"
CLOSE: "close"

UN_PLUS: "++"
UN_MINUS: "--"

FLOORDIV: "//"
POW: "**"

EQ_EQ: "=="
NOT_EQ: "!="
GT: ">"
LT: "<"
GE: ">="
LE: "<="

ID: /(?!(and|or|true|false|read|show|clr|exit|if|elif|else|while|for|in|range|fn|ret|try|fail|always|todo|array_add|array_remove|int|float|close)\b)/ /[a-zA-Z_][a-zA-Z0-9_]*/
INT_LITERAL: /[0-9]+/
FLOAT_LITERAL: /[0-9]+\.[0-9]+/
STR_LITERAL: /'([^'\\]|\\.)*'/
NEWLINE: /\r?\n/

M_COMMENT: /(?s)###.*?###/
S_COMMENT: /#[^\n]*/

%ignore M_COMMENT
%ignore S_COMMENT

%ignore /[ \t]+/